esphome:
  name: desal
  friendly_name: Desalination Controller
  platformio_options:
    board_build.arduino.memory_type: qio_opi
    board_upload.maximum_ram_size: 524288
  <<: !include .boot_jan.yaml
# Use .boot.yaml for full year
esp32:
  board: esp32-s3-devkitc-1
  variant: esp32s3
  flash_size: 16MB
  partitions: "/config/esphome/default_16MB.csv"
  framework:
    type: arduino

psram:
  mode: octal
  speed: 80MHz

external_components:
  - source: github://pr#7621
    refresh: 0d
    components: [ time ]

# Enable logging
logger:
  level: debug

# # Temporary WiFi connect for debug.  Open on PC URL = tides.local/
# wifi:
  # ssid: "GreenMountain"
  # password: !secret wifi_password

# # Enable Home Assistant API
# api:
  # encryption:
    # key: !secret api_encryption_key

# ota:
  # - platform: esphome
    # password: !secret ota_password

wifi:
  ap:
    ssid: "Thetis"
    password: "SmiLinCove216"
    
web_server:
  port: 80
  version: 3
  ota: true
  log: true
  local: true
  sorting_groups:
    - id: sorting_group_message
      name: "Message"
      sorting_weight: 1
    - id: sorting_group_pumps
      name: "Pumps"
      sorting_weight: 3
    - id: sorting_group_levels
      name: "Levels"
      sorting_weight: 2
    - id: sorting_group_other
      name: "Other"
      sorting_weight: 4
    - id: sorting_group_timeset
      name: "Time Set"
      sorting_weight: 5
    - id: sorting_group_config
      name: "Config"
      sorting_weight: 6


globals:
  - id: TIDE_TABLE
    type: std::array<uint8_t, 4416> # Maxiumum for a leap year
  - id: dayAddress
    type: int
  - id: height
    type: int
  - id: rising
    type: int
  - id: sw_tank_size
    type: int
    initial_value: "1000"
  - id: fw_tank_size
    type: int
    initial_value: "2000"
  - id: sw_min_on # Prevent Saltwater pump from short cycling
    type: int
    initial_value: "300000"  # Must be ON at least 5 minutes
# Time component to get the current time from an NTP server 
# Need to add a RTC so that above WiFi connection can be removed
# calculate dayAddress 10 seconds after midnight when month and day may change.
# Calculate tide height every minute and compare with min_height to change pump state.
i2c:
  sda: GPIO01
  scl: GPIO02
  scan: true
  id: bus_a

time:
  - platform: ds1307 
    id: rtc_time
    on_time:
      - seconds: 10
        minutes: /1
        then:
          - lambda: |-
              auto now = id(rtc_time).now();
              int month = now.month;
              int day = now.day_of_month;
              int days = 0;
              int year = now.year;
              int min_height = id(min_height_num).state * 10;
              ESP_LOGD("main", "Loop: %d %d %d", month,day,year);
              int monthSize[12] = {31,28,31,30,31,30,31,31,30,31,30,31};
              if (((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0)) {
                int monthSize[12] = {31,29,31,30,31,30,31,31,30,31,30,31};
              } else {
                int monthSize[12] = {31,28,31,30,31,30,31,31,30,31,30,31};
              }
              for (int i = 0; i < 12; i++) {
                if (i == (month - 1) or month == 1) {
                  break; }
                days = days + monthSize[i];
                } 
              id(dayAddress) = (days + day) * 12;
              int dayMinute = now.hour * 60 + now.minute;
              int t0 = 0;
              int h0 = 0;
              int t1 = 0;
              int h1 = 0;
              uint8_t byte1 = 0;
              uint8_t byte2 = 0;
              float tideLevel = 0;
              float m = 0.1;
              float b = 0.2;
              int dayMinuteShifted = dayMinute + 1440;
              for (int i = 0; i < 6; i++) {
                byte1 = id(TIDE_TABLE)[id(dayAddress) + i * 3 - 3];
                byte2 = id(TIDE_TABLE)[id(dayAddress) + i * 3 - 2];
                t1 = (byte1 << 8) | byte2;
                h1 = id(TIDE_TABLE)[id(dayAddress) + i * 3 - 1] - 10;
                if (i > 0) {
                  t1 += 1440;
                  if (i == 5) {
                    t1 += 1440;
                  }
                  if (t1 != t0) {
                    m = float(h1 - h0) / float(t1 - t0);
                    b = float(h0) - m * float(t0);
                    if (dayMinuteShifted >= t0 and dayMinuteShifted < t1) {
                      tideLevel = m * (dayMinute + 1440) + b;
                      id(height) = static_cast<int>(tideLevel);
                      if ( m > 0) {
                        id(rising) = 1;
                      } else {
                        id(rising) = 0;
                      }
                    }
                    //ESP_LOGD("main", "Loop: %d %d %d %d %d %d %d %d %d",id(dayAddress), i, dayMinute + 1440, t1, h1, t0, h0, id(height), id(rising)); 
                  }
                }
                t0 = t1;
                h0 = h1;
              }
      - seconds: 30
        minutes: /1
        then:
          - lambda: |-
              int new_level = id(sw_level).state;
              int tmp = 0;
              int begin_time = 0;
              int min_height = id(min_height_num).state * 10;
              float float_new_level = id(fw_level).state;
              // Start SW pump if tide is up and level is low.  Keep pumping until full
              if (id(height) > min_height) {
                if (id(sw_level).state < id(sw_refill_level).state and !id(sw_pump).state) {
                  begin_time = millis();
                  //ESP_LOGD("main", "Begin: %d %d",begin_time, id(sw_min_on)); 
                  id(sw_pump).turn_on();
                }
                if ((id(sw_level).state >= id(sw_tank_size)) and id(sw_pump).state and (millis() - begin_time) > id(sw_min_on)) {
                  id(sw_pump).turn_off();
                }
              }
              else {
                if ((id(sw_pump).state) and (millis() - begin_time) >= id(sw_min_on)) {
                  tmp = millis() - begin_time;
                  //ESP_LOGD("main", "End: %d %d",begin_time, millis());
                  id(sw_pump).turn_off();
                }
              }
              //Using SW Tank
              if(id(booster_pump).state){
                new_level = new_level - id(sw_use_rate).state ;
                //ESP_LOGD("main", "SW New Level: %d", new_level);
                if (new_level < 0) {
                  new_level = 0;
                }
              }
              //Filling SW Tank
              if(id(sw_pump).state){
                new_level = new_level + id(sw_fill_rate).state;
                if (new_level > id(sw_tank_size)) {
                  new_level = id(sw_tank_size);
                }
              }
              if(id(sw_pump).state or id(booster_pump).state) {
                auto call1 = id(sw_level).make_call();
                call1.set_value(new_level);
                call1.perform();
              }
              //Using FW Tank
              auto now = id(rtc_time).now();
              int hour = now.hour;
              if(hour > id(fw_start_hour).state and hour < id(fw_stop_hour).state) {
                float_new_level = float_new_level - id(fw_use_rate).state;
                if (float_new_level < 0) {
                  float_new_level = 0;
                }
              }
              //Filling FW Tank
              if(id(hp_pump).state){
                float_new_level = float_new_level + id(sw_use_rate).state * id(ro_recovery).state / 100 ; 
              }              
              if((hour > id(fw_start_hour).state and hour < id(fw_stop_hour).state) or id(hp_pump).state) {
                auto call2 = id(fw_level).make_call();
                call2.set_value(float_new_level);
                call2.perform();
              }
              // Booster then HP Pump Control
              if (id(fw_level).state >= id(fw_tank_size) or id(sw_level).state < id(sw_min_level).state) {
                id(stop_desal)->execute(id(hp_stop_delay).state * 1000); 
              }
              if (id(fw_level).state < id(fw_min_level).state and id(sw_level).state > id(sw_min_level).state * 2) {
                id(start_desal)->execute(id(hp_start_delay).state * 1000);
              }


script:
  - id: start_desal
    parameters:
      delay_ms: int
    mode: single  # Prevent the `wait` from running multiple times concurrently
    then:
      - switch.turn_on: booster_pump
      - delay: !lambda return delay_ms;
      - switch.turn_on: hp_pump
  - id: stop_desal
    parameters:
      delay_ms: int
    mode: single  # Prevent the `wait` from running multiple times concurrently
    then:
      - switch.turn_off: hp_pump
      - delay: !lambda return delay_ms;
      - switch.turn_off: booster_pump

# Identify the version on startup
# and then use for state messages

switch:
  - platform: gpio
    name: "HP Pump"
    id: hp_pump
    pin:
      number: GPIO16
      inverted: True
  - platform: gpio
    name: "SW Pump"
    id: sw_pump
    pin:
      number: GPIO17
      inverted: True
  - platform: gpio
    name: "Booster Pump"
    id: booster_pump
    pin:
      number: GPIO18
      inverted: True            

sensor:
  - platform: template
    name: "Tide Height"
    state_class: measurement
    unit_of_measurement: "ft"
    lambda: |-
      return float(id(height)) / 10;    
    update_interval: 60s

binary_sensor:
  - platform: template
    name: "Tide Direction"
    lambda: |-
      if (id(rising) == 1) {
        return true;
      } else {
        return false;
      }

number: 
  - platform: template 
    name: "Minimum Height"
    id: min_height_num
    unit_of_measurement: ft
    optimistic: true
    mode: slider
    min_value: 1
    max_value: 10
    step: 0.10
    initial_value: 6.0
    restore_value: true
  - platform: template 
    name: "HP Start Delay"
    id: hp_start_delay
    unit_of_measurement: sec
    optimistic: true
    mode: box
    min_value: 1
    max_value: 5
    step: 1
    initial_value: 5
    restore_value: true
  - platform: template 
    name: "HP Stop Delay"
    id: hp_stop_delay
    unit_of_measurement: sec
    optimistic: true
    mode: box
    min_value: 1
    max_value: 10
    step: 1
    initial_value: 5
    restore_value: true
  - platform: template 
    name: "SW Min Level"
    id: sw_min_level
    unit_of_measurement: "gal"
    optimistic: true
    mode: box
    min_value: 0
    max_value: 250
    step: 1
    initial_value: 100
    restore_value: true
  - platform: template 
    name: "SW Refill Level"
    id: sw_refill_level
    unit_of_measurement: "gal"
    optimistic: true
    mode: box
    min_value: 0
    max_value: 900
    step: 1
    initial_value: 600
    restore_value: true
  - platform: template 
    name: "FW Min Level"
    id: fw_min_level
    unit_of_measurement: "gal"
    optimistic: true
    mode: box
    min_value: 800
    max_value: 1000
    step: 1
    initial_value: 950
    restore_value: true
  # Set Date Times
  - platform: template 
    name: "Year"
    id: dt_year
    optimistic: true
    mode: box
    min_value: 2025
    max_value: 2100
    step: 1
    initial_value: 2025
    restore_value: true
  - platform: template 
    name: "Month"
    id: dt_month
    optimistic: true
    mode: box
    min_value: 1
    max_value: 12
    step: 1
    initial_value: 1
  - platform: template 
    name: "Day"
    id: dt_day
    optimistic: true
    mode: box
    min_value: 1
    max_value: 31
    step: 1
    initial_value: 1
  - platform: template 
    name: "Hour"
    id: dt_hour
    optimistic: true
    mode: box
    min_value: 0
    max_value: 23
    step: 1
    initial_value: 12
  - platform: template 
    name: "Minute"
    id: dt_minute
    optimistic: true
    mode: box
    min_value: 1
    max_value: 59
    step: 1
    initial_value: 0
  # Simulation components
  - platform: template 
    name: "SW Level"
    id: sw_level
    unit_of_measurement: "gal"
    optimistic: true
    mode: slider
    min_value: 0
    max_value: 1000
    step: 1
    initial_value: 0
  - platform: template 
    name: "FW Level"
    id: fw_level
    unit_of_measurement: "gal"
    optimistic: true
    mode: slider
    min_value: 0
    max_value: 1100
    step: 1
    initial_value: 0
  - platform: template 
    name: "SW Fill Rate"
    id: sw_fill_rate
    unit_of_measurement: "gpm"
    optimistic: true
    mode: box
    min_value: 0
    max_value: 50
    step: 1
    initial_value: 35
  - platform: template 
    name: "SW Use Rate"
    id: sw_use_rate
    unit_of_measurement: "gpm"
    optimistic: true
    mode: box
    min_value: 0
    max_value: 10
    step: 1
    initial_value: 5
  - platform: template 
    name: "RO Recovery"
    id: ro_recovery
    unit_of_measurement: "%"
    optimistic: true
    mode: box
    min_value: 1
    max_value: 25
    step: 1
    initial_value: 15
  - platform: template 
    name: "FW Use Rate"
    id: fw_use_rate
    unit_of_measurement: "gpm"
    optimistic: true
    mode: box
    min_value: 0
    max_value: 1.0
    step: 0.01
    initial_value: 0.47
  - platform: template 
    name: "FW Start Hour"
    id: fw_start_hour
    unit_of_measurement: "hr"
    optimistic: true
    mode: box
    min_value: 5
    max_value: 12
    step: 1
    initial_value: 8
  - platform: template 
    name: "FW Stop Hour"
    id: fw_stop_hour
    unit_of_measurement: "hr"
    optimistic: true
    mode: box
    min_value: 13
    max_value: 23
    step: 1
    initial_value: 22

light:
  - platform: esp32_rmt_led_strip
    rgb_order: GRB
    pin: GPIO48
    num_leds: 1
    rmt_channel: 0
    chipset: sk6812
    name: "My Light"

text_sensor:
  - platform: template
    name: "Date/Time"
    id: current_time
    lambda: |-
      auto time = id(rtc_time).now();
      return time.strftime("%Y-%m-%d / %H:%M");

button:
  - platform: template
    name: "Set Time"
    id: set_time_button
    on_press:
      lambda: |-
        ESP_LOGD("main", "Button Pressed");
        int year = id(dt_year).state;
        int month = id(dt_month).state;
        int day = id(dt_day).state;
        int hour = id(dt_hour).state;
        int minute = id(dt_minute).state;
        id(rtc_time).set_time(year, month, day, hour, minute, 0);
        auto time = id(rtc_time).now();
        id(current_time).publish_state(time.strftime("%Y-%m-%d / %H:%M"));
